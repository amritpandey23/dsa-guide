{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"arrays/patterns/sliding_window/","title":"Sliding Window","text":""},{"location":"arrays/patterns/sliding_window/#introduction","title":"Introduction","text":"<p>The Sliding Window technique is a powerful algorithmic approach used for problems involving arrays or lists where we need to find a subarray satisfying a given condition. Instead of iterating through all possible subarrays using nested loops (which is inefficient), we use a window that moves dynamically through the array, improving efficiency.</p>"},{"location":"arrays/patterns/sliding_window/#when-to-use-sliding-window","title":"When to Use Sliding Window?","text":"<p>You should consider using the Sliding Window technique when:</p> <ul> <li>The problem involves a contiguous subarray or substring.</li> <li>There\u2019s a need for optimization in an array traversal.</li> <li>The brute-force approach involves nested loops, leading to an inefficient time complexity.</li> </ul>"},{"location":"arrays/patterns/sliding_window/#types-of-sliding-window","title":"Types of Sliding Window","text":"<p>Sliding Window problems generally fall into two categories:</p> <ol> <li>Fixed-size Sliding Window: The window size remains constant.</li> <li>Variable-size Sliding Window: The window expands or shrinks based on conditions.</li> </ol>"},{"location":"arrays/patterns/sliding_window/#1-fixed-size-sliding-window","title":"1. Fixed-size Sliding Window","text":"<p>This approach is used when the size of the window (subarray) is predefined.</p>"},{"location":"arrays/patterns/sliding_window/#example-1-maximum-sum-of-k-consecutive-elements","title":"Example 1: Maximum Sum of K Consecutive Elements","text":"<p>Problem Statement: Given an array of integers and an integer <code>k</code>, find the maximum sum of <code>k</code> consecutive elements in the array.</p>"},{"location":"arrays/patterns/sliding_window/#brute-force-approach","title":"Brute Force Approach","text":"<p>From each element we will read next <code>k</code> elements and calculate the sum. This sum will be calcuated against the maximum sum received so far.</p> <p>Time Complexity:  </p> Java <pre><code>public int maxSumBruteForce(int[] arr, int k) {\n    int maxSum = Integer.MIN_VALUE;\n    for (int i = 0; i &lt;= arr.length - k; i++) {\n        int sum = 0;\n        for (int j = i; j &lt; i + k; j++) {\n            sum += arr[j];\n        }\n        maxSum = Math.max(maxSum, sum);\n    }\n    return maxSum;\n}\n</code></pre>"},{"location":"arrays/patterns/sliding_window/#optimized-sliding-window-approach","title":"Optimized Sliding Window Approach","text":"<ol> <li>Compute the sum of the first <code>k</code> elements.</li> <li>Slide the window by removing the first element and adding the next element.</li> <li>Keep track of the maximum sum encountered.</li> </ol> <p>Time Complexity:  </p> Java <pre><code>public int maxSumSlidingWindow(int[] arr, int k) {\n    int maxSum = 0, windowSum = 0;\n\n    // Compute sum of the first k elements\n    for (int i = 0; i &lt; k; i++) {\n        windowSum += arr[i];\n    }\n    maxSum = windowSum;\n\n    // Slide the window across the array\n    for (int i = k; i &lt; arr.length; i++) {\n        windowSum += arr[i] - arr[i - k]; // Add new element, remove old one\n        maxSum = Math.max(maxSum, windowSum);\n    }\n\n    return maxSum;\n}\n</code></pre>"},{"location":"arrays/patterns/sliding_window/#2-variable-size-sliding-window","title":"2. Variable-size Sliding Window","text":"<p>This approach is useful when the window size is not fixed and needs to be dynamically adjusted based on some condition.</p>"},{"location":"arrays/patterns/sliding_window/#example-2-smallest-subarray-with-sum-s","title":"Example 2: Smallest Subarray with Sum \u2265 <code>S</code>","text":"<p>Problem Statement: Given an array of positive integers and a number <code>S</code>, find the minimal length of a contiguous subarray whose sum is greater than or equal to <code>S</code>. If no such subarray exists, return <code>0</code>.</p>"},{"location":"arrays/patterns/sliding_window/#sliding-window-approach","title":"Sliding Window Approach","text":"<ol> <li>Expand the window by adding elements from the right.</li> <li>Shrink the window from the left as long as the sum remains \u2265 <code>S</code>.</li> <li>Track the minimum window length that satisfies the condition.</li> </ol> <p>Time Complexity:  </p> Java <pre><code>public int minSubArrayLen(int S, int[] arr) {\n    int minLength = Integer.MAX_VALUE, windowSum = 0;\n    int left = 0;\n\n    for (int right = 0; right &lt; arr.length; right++) {\n        windowSum += arr[right]; // Expand window\n\n        while (windowSum &gt;= S) { // Shrink window\n            minLength = Math.min(minLength, right - left + 1);\n            windowSum -= arr[left];\n            left++;\n        }\n    }\n\n    return (minLength == Integer.MAX_VALUE) ? 0 : minLength;\n}\n</code></pre>"},{"location":"arrays/patterns/sliding_window/#related-problems","title":"Related Problems","text":"<ol> <li>Longest Substring Without Repeating Characters (LeetCode 3)</li> <li>Maximum Sum Subarray of Size K (LeetCode 53)</li> <li>Permutation in String (LeetCode 567)</li> <li>Longest Repeating Character Replacement (LeetCode 424)</li> <li>Longest Subarray of 1s After Deleting One Element (LeetCode 1493)</li> </ol>"},{"location":"dynamic_programming/editorials/coin_sum_combination/","title":"Problem - Coin Sum Combination","text":"<p>Given a set of coin values and sum value, our job is to find out the number of ways in which we can include the coins to make the sum value possible. A coin can be picked any number of times.</p> <p>Leetcode Problem: 518. Coin Change II</p>"},{"location":"dynamic_programming/editorials/coin_sum_combination/#solution-using-dp-map","title":"Solution using DP Map","text":"<pre><code>class CoinSumCombination {\n    public int getCount(int[] coins, int val) {\n        int m = val, n = coins.length;\n        int[][] dp = new int[m + 1][n + 1];\n\n        for (int i = 0; i &lt;= m; ++i) {\n            for (int j = 0; j &lt;= n; ++j) {\n                if (i == 0) {\n                    dp[i][j] = 1; // to make sum zero there is 1 way (not include that coin);\n                } else if (j == 0) {\n                    dp[i][j] = 0; // for sum &gt; 0 there is no way to make that sum by including no coins\n                } else {\n                    dp[i][j] = dp[i][j - 1]; // store number of ways it was possible to make the sum\n                    // by including coins before this coin.\n                    if (coins[j - 1] &lt;= i) {\n                        // if sum is less than the current coin value\n                        int remainingSum = i - coins[j - 1];\n                        dp[i][j] += dp[remainingSum][j];\n                    }\n                }\n            }\n        }\n\n        return dp[m][n];\n    }\n}\n</code></pre>"},{"location":"dynamic_programming/editorials/longest_common_subsequence/","title":"Problem - Longest Common Subsequence in a String","text":"<p>Given two strings <code>s1</code> and <code>s2</code> of length <code>m</code> and <code>n</code> respectively we have to find the long common subsequence of characters in both.</p> <p>Leetcode Problem: 1143. Longest Common Subsequence</p>"},{"location":"dynamic_programming/editorials/longest_common_subsequence/#solution-using-recursion-and-memoization","title":"Solution using recursion and memoization","text":"<pre><code>class Memoization {\n    public int lcs(String s1, String s2, int m, int n, int[][] memo) {\n        if (m == 0 || n == 0) {\n            // length of either of string becomes 0\n            // solution is always 0 in this case\n            memo[m][n] = 0;\n            returm memo[m][n];\n        }\n        if (memo[m][n] != -1) {\n            // was this state already solved?\n            return memo[m][n];\n        }\n        if (s1.charAt(m - 1) == s2.charAt(n - 1)) {\n            // found same character\n            memo[m][n] = 1 + lcs(s1, s2, m - 1, n - 1, memo);\n        } else {\n            // max of two different solution space\n            memo[m][n] = Math.max(lcs(s1, s2, m, n - 1, memo), lcs(s1, s2, m - 1, n, memo));\n        }\n        return memo[m][n];\n    }\n}\n</code></pre>"},{"location":"dynamic_programming/editorials/longest_common_subsequence/#solution-using-dp-map","title":"Solution using dp map","text":"<pre><code>class DPMap {\n    public int lcs(String s1, String s2) {\n        int m = s1.length, n = s2.length;\n        int[][] dp = new int[m + 1][n + 1];\n\n        for (int i = 0; i &lt;= m; ++i) {\n            for (int j = 0; j &lt;= n; ++j) {\n                if (i == 0 || j == 0) {\n                    dp[i][j] = 0;\n                } else if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\n                    dp[i][j] = 1 + dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n\n        return dp[m][n];\n    }\n}\n</code></pre>"},{"location":"dynamic_programming/patterns/interval_range/","title":"Dynamic Programming - Interval/Range","text":""},{"location":"dynamic_programming/patterns/interval_range/#scenario","title":"Scenario","text":"<p>Problem where the data can be divided into sub-intervals of a large intervals.</p>"},{"location":"dynamic_programming/patterns/interval_range/#clue","title":"Clue","text":"<p>Look for problems where the optimal solution can be derived from optimal solutions of its sub-intervals.</p>"},{"location":"dynamic_programming/patterns/interval_range/#problems","title":"Problems","text":"Problem Link Platform Minimum Falling Path Sum Link Burst Balloons Link Partition Equal Subset Sum Link Strange Printer Link Maximum Vacation Days Link"},{"location":"dynamic_programming/patterns/optimal_substructure/","title":"Dynamic Programming - Optimal Substructure","text":""},{"location":"dynamic_programming/patterns/optimal_substructure/#scenario","title":"Scenario","text":"<p>Problem where the optimal solution can be constructed from optimal solutions of it's sub-problems.</p>"},{"location":"dynamic_programming/patterns/optimal_substructure/#clue","title":"Clue","text":"<p>Can the problem be broken into sub-problems to get the optimal solution?</p>"},{"location":"dynamic_programming/patterns/optimal_substructure/#problems","title":"Problems","text":"Problem Link Platform Maximum Subarray Link Longest Increasing Subsequence Link Coin Change Link Edit Distance Link Longest Common Subsequence Link"},{"location":"dynamic_programming/patterns/traversal/","title":"Dynamic Programming - Traversal","text":""},{"location":"dynamic_programming/patterns/traversal/#scenario","title":"Scenario","text":"<p>Problems where making recursive calls need to redundant computation leading to inefficiencies. The result can be optimized by storing the results of previously computed operations in a data structure.</p>"},{"location":"dynamic_programming/patterns/traversal/#clue","title":"Clue","text":"<p>Look for recursive problems where subproblems are overlapping or repetitive.</p>"},{"location":"dynamic_programming/patterns/traversal/#problems","title":"Problems","text":"Problem Link Platform Fibonacci Number Link Climbing Stairs Link House Robber Link Unique Paths Link Minimum Path Sum Link"},{"location":"graph/algorithms/bellman_ford_algorithm/","title":"Bellman Ford Algorithm","text":"<p>Bellman Ford algorithm is used to find the shortest distance from given node. It is a dynamic programming algorithm.</p> <p>We have to be given a set of edges with their weights and total number of nodes.</p> Java <pre><code>public class BFA {\n    public static int[] getShortestDistances(int node, int totalNodes, Edge[] edges) {\n        int[] distances = new int[totalNodes];\n        Arrays.fill(distances, Integer.MIN_VALUE);\n        distances[node] = 0;\n        int totalNodesProcessed = 1;\n        for (int v = 1; v &lt; totalNodesProcessed, v++) {\n            for (Edge e : edges) {\n                if (distances[e.dest] &gt; distances[e.src] + e.wt) {\n                    distances[e.dest] = distances[e.src] + e.wt;\n                }\n            }\n        }\n        return distances;\n    }\n\n    private class Edge {\n        int src;\n        int dest;\n        int wt;\n\n        public Edge(int src, int dest, int wt) {\n            this.src = src;\n            this.dest = dest;\n            this.wt = wt;\n        }\n    }\n}\n</code></pre>"},{"location":"graph/algorithms/detect_cycle_in_directed_graph/","title":"Detect Cycle in Directed Graph","text":"<p>Given a directed graph represented as an adjacency list, the task is to determine if the graph contains any cycles.</p> <pre><code>graph LR\n    1 --&gt; 2\n    2 --&gt; 3\n    3 --&gt; 4\n    4 --&gt; 2</code></pre>"},{"location":"graph/algorithms/detect_cycle_in_directed_graph/#depth-first-search-dfs-approach","title":"Depth-First Search (DFS) Approach","text":"<p>In an undirected graph, we use a <code>visited[]</code> array to track visited nodes and detect if a node is revisited while doing depth first search thus indicating a cycle. However, this approach does not work for directed graphs because nodes can be visited multiple times from different paths and yet count of multiple visit to a same node won't indicate the presence of a cycle.</p> <p>For example, consider the following graph:</p> <pre><code>graph LR\n    1 --&gt; 2\n    3 --&gt; 2</code></pre> <p>Here, node 2 can be visited twice  and , however a simple DFS keeping the track of visited nodes cannot indicate the presence of a cycle.</p>"},{"location":"graph/algorithms/detect_cycle_in_directed_graph/#observing-sub-graphs","title":"Observing Sub-Graphs","text":"<p>A directed graph can be seen as a collection of sub-graphs. In the graph above, there are two sub-graphs: <code>1 \u2192 2</code> and <code>3 \u2192 2</code>. Running a cycle detection algorithm independently on each sub-graph will detect cycles for that particular sub-graph. Once the algorithm is complete for one sub-graph, we can unmark all the nodes which were visisted in one sub-graph and prepare them for a revisit again from another sub-graph.</p> <p>While this approach works, it is inefficient as it repeatedly runs DFS on nodes where the checks were already done previously.</p>"},{"location":"graph/algorithms/detect_cycle_in_directed_graph/#optimized-dfs-algorithm","title":"Optimized DFS Algorithm","text":"<p>We can optimize the above approach by:</p> <ol> <li>Initializing the <code>visited[]</code> array once.</li> <li>Introducing a <code>processed[]</code> array to track sub-graphs already checked for cycles.</li> </ol> <p>Here\u2019s the code:</p> Python <pre><code>def detectCycle(graph):\n    visited = [False] * len(graph)\n    processed = [False] * len(graph)\n\n    for node in range(len(graph)):\n        if not processed[node]:\n            if detectCycleUtil(node, graph, visited, processed):\n                return True\n\n    return False\n\ndef detectCycleUtil(node, graph, visited, processed):\n    visited[node] = True\n    processed[node] = True\n\n    for nbr in graph[node]:\n        if visited[nbr]:  # Cycle detected\n            return True\n        elif detectCycleUtil(nbr, graph, visited, processed):\n            return True\n\n    visited[node] = False\n    return False\n</code></pre>"},{"location":"graph/algorithms/detect_cycle_in_directed_graph/#breadth-first-search-bfs-approach","title":"Breadth-First Search (BFS) Approach","text":"<p>To understand the BFS-based approach, it\u2019s essential to first understand topological sorting of directed graphs. </p> <p>Consider the graph below:</p> <pre><code>graph LR\n    1 --&gt; 2\n    2 --&gt; 3\n    3 --&gt; 4\n    1 --&gt; 4</code></pre> <p>This graph can be viewed as a dependency graph, where if you want to processing node <code>1</code> then it can be seen that it requires prior processing of nodes <code>2</code> and <code>4</code> first. Now, if we go on to process node <code>2</code> the we can also see that it then require processing of node <code>3</code> which then again require processing of node <code>4</code>. Hence in order to process node <code>1</code> we have to go in processing order as follows: . This order is know is topological order of the graph.</p>"},{"location":"graph/algorithms/detect_cycle_in_directed_graph/#topological-sorting-algorithm","title":"Topological Sorting Algorithm","text":"<p>Topological sorting processes nodes in decreasing order of their in-degrees. Below is the algorithm to print the topological order of a directed graph.</p> JavaPython <pre><code>public class TopologicalSorting {\n    public void sort(int n, int[][] edges) {\n        int[] indegrees = new int[n];\n        List&lt;Integer&gt;[] graph = new ArrayList[n]; \n\n        for (int[] edge : edges) {\n            int from = edge[0];\n            int to = edge[1];\n            indgrees[to]++;\n            if (graph[from] == null) {\n                graph[from] == new ArrayList&lt;&gt;();\n            }\n            graph[from].add(to);\n        }\n\n        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();\n        for (int i = 0; i &lt; n; ++i) {\n            if (indegrees[i] == 0) {\n                queue.add(i);\n            }\n        }\n\n        while (queue.size() &gt; 0) {\n            int curr = queue.poll();\n            // process curr here\n            for (int nbr : graph[curr]) {\n                indegrees[nbr]--;\n                if (indegrees[nbr] == 0) {\n                    queue.add(nbr); // process 0 indegree nodes\n                }\n            }\n        }\n    }\n}\n</code></pre> <pre><code>def topological_sort(graph):\n    indegrees = [0] * len(graph)\n\n    # Compute in-degrees of all nodes\n    for node in range(len(graph)):\n        for nbr in graph[node]:\n            indegrees[nbr] += 1\n\n    queue = []\n    for node in range(len(graph)):\n        if indegrees[node] == 0:  # Add nodes with 0 in-degree\n            queue.append(node)\n\n    while queue:\n        n = queue.pop(0)\n        print(n)  # Process node\n        for nbr in graph[n]:\n            indegrees[nbr] -= 1  # Decrement in-degree\n            if indegrees[nbr] == 0:\n                queue.append(n)\n</code></pre>"},{"location":"graph/algorithms/detect_cycle_in_directed_graph/#khans-algorithm-for-cycle-detection","title":"Khan's Algorithm for Cycle Detection","text":"<p>There is an interesting observation that can be made. Let's suppose the graph looks like this:</p> <pre><code>graph LR\n    1 --&gt; 2\n    2 --&gt; 3\n    3 --&gt; 1\n    1 --&gt; 4</code></pre> <p>We can see that a cycle exist in the graph and also conclude that no matter how we process this graph, topological sort can never exist!</p> <p>Khan's algorithm is a modification of the topological sorting algorithm. By counting the nodes added to the queue, we can determine if the graph contains a cycle. If the count of processed nodes equals the total number of nodes in the graph, it implies the absence of cycles.</p> Python <pre><code>def detect_cycle(graph):\n    indegrees = [0] * len(graph)\n\n    # Compute in-degrees of all nodes\n    for node in range(len(graph)):\n        for nbr in graph[node]:\n            indegrees[nbr] += 1\n\n    queue = []\n    count = 0\n\n    for node in range(len(graph)):\n        if indegrees[node] == 0:\n            queue.append(node)\n            count += 1\n\n    while queue:\n        n = queue.pop(0)\n        for nbr in graph[n]:\n            indegrees[nbr] -= 1\n            if indegrees[nbr] == 0:\n                queue.append(nbr)\n                count += 1\n\n    return count != len(graph)\n</code></pre>"},{"location":"graph/algorithms/detect_cycle_in_directed_graph/#related-problems","title":"Related Problems","text":"<ol> <li>Leetcode - 207. Course Schedule</li> <li>Leetcode - 2392. Build a Matrix With Conditions</li> </ol>"},{"location":"graph/algorithms/dijkstra_shortest_path/","title":"Dijkstra Shortest Path Algorithm","text":"<p>DSP is a graph algorithm to find out the shortest distance to every node starting from a given node.</p> Java <pre><code>public class DSP {\n    public static void findShortestPath(int node, List&lt;Pair&gt;[] graph) {\n        PriorityQueue&lt;Pair&gt; queue = new PriorityQueue&lt;&gt;((p1, p2) -&gt; {\n            return p2.dist - p1.dist;\n        });\n        boolean[] seen = new boolean[graph.length];\n        queue.add(new Pair(node, 0));\n        while (!queue.isEmpty()) {\n            int curr = queue.poll();\n            seen[curr] = true;\n            // process the node here\n            for (Pair nbr : graph) {\n                if (!seen[nbr.node]) {\n                    queue.add(new Pair(nbr.node, nbr.dist));\n                }\n            }\n        }\n    }\n\n    public static class Pair {\n        int node;\n        int dist;\n\n        public Pair(int node, int dist) {\n            this.node = node;\n            this.dist = dist;\n        }\n    }\n}\n</code></pre>"},{"location":"math/formulas/","title":"Math Formulas and Tricks","text":"<p>Here we are going to discuss common math formula and tricks used in programming.</p>"},{"location":"math/formulas/#greatest-common-divisor","title":"Greatest Common Divisor","text":"<p>GCD or Highest Common Factor(HCF) is the largest value number which can divide two given numbers. For example GCD of  is  as it is the largest number which can divide both   and .  To find a GCD of two numbers both of them must be non-zero.</p> Java <pre><code>class GCD {\n    // recursive:\n    public int gcd(int a, int b) {\n        if (b == 0) {\n            return a;\n        }\n        return (b, a % b);\n    }\n\n    // iterative:\n    public int gcdIter(int a, int b) {\n        while (a != b) {\n            if (a &gt; b) {\n                a = a - b;\n            } else {\n                b = b - a;\n            }\n        }\n        return a;\n    }\n}\n</code></pre>"},{"location":"math/formulas/#related-problems","title":"Related Problems","text":"<ol> <li>A. Playing with Paper</li> </ol>"},{"location":"math/formulas/#lowest-common-multiple","title":"Lowest Common Multiple","text":"<p>LCM is the lowest value number (except 1) which can be divided by given two numbers. For example LCM of  is . The formula of LCM requires the GCD value of two given numbers and then we can have LCM as follows:</p> <p> </p> Java <pre><code>public class LCM {\n    public int lcm(int x, int y) {\n        return (x * y) / gcd(x, y);\n    }\n}\n</code></pre>"},{"location":"math/formulas/#check-for-prime","title":"Check for Prime","text":"<p>Prime numbers in Math are the numbers which can be divided by  and the number themselves. For example  etc. are all prime numbers.  is not considered prime number. Negative numbers cannot be prime.</p> <p>An interesting observation in natural numbers line is that prime numbers always repeat themselves at a factored length of  and  starting from number .</p> Java <pre><code>public class CheckPrime {\n    public boolean isPrime(int x) {\n        if (x == 1) {\n            return false; // 1 is not considered prime\n        }\n        if (x == 2 || x == 3) {\n            return true; // 2 and 3 are basic primes\n        }\n        if (x % 2 == 0 || x % 3 == 0) {\n            return false;\n        }\n        for (int i = 5; i * i &lt;= x; i += 6) {\n            // two prime numbers always repeat together\n            // on the natural line number at an interval\n            // of factored length of 6 and 8 from the \n            // last prime number\n            if (x % i == 0 || (x + 2) % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n</code></pre>"},{"location":"math/formulas/#power-of-a-number","title":"Power of a number","text":"<p>The power, let's say  of a number  is the value which we get if get to multiple the number by itself  number of times.</p> <p> </p> <p>In programming we can use a neat trick called binary exponentiation to calculate a power of a number in  time instead of  time.</p> Java <pre><code>public class Power{\n    /*\n    Recursive Version\n    */\n    public long powRec(int x, int y) {\n        if (y == 0) {\n            return x;\n        }\n        if (y % 2 == 1) {\n            // factor in extra 'x'\n            return x * pow(x, y / 2) * pow(x, y / 2);\n        }\n        return pow(x, y / 2) * pow(x, y / 2);\n    }\n\n    /*\n    Iterative version\n    */\n    public long powIter(int x, int y) {\n        int ans = 1;\n        while (y &gt; 0) {\n            if ((y &amp; 1) == 1) {\n                // factor in extra 'x'\n                ans *= x;\n            }\n            x *= x;\n            y = y &gt;&gt; 1;\n        }\n        return ans;\n    }\n}\n</code></pre>"},{"location":"math/formulas/#related-problems_1","title":"Related Problems","text":"<ol> <li>50. Pow(x, n)</li> </ol>"},{"location":"math/formulas/#permutation","title":"Permutation","text":"<p>A permutation is arrangement of objects in a specific order after being picked up from a set of elements. The permutation can be after picking less number of objects from the set of elements. For example, for a set of  if we want permutation of two elements we will get permutation as .</p> <p>There is specifc formula to calcuate the number of permutations which we can get after picking  elements from a set of  elements as:</p> <p> </p> <p>where  and  are the factorial.</p> <p>In above example we can calculate permutations as:</p> <p> </p>"},{"location":"math/formulas/#combination","title":"Combination","text":"<p>If we only have to count the combinations of different element without taking into account their arrangements then we calcuate the combination as follows:</p> <p> </p>"},{"location":"matrix/matrix_operations/","title":"Operations on Matrices","text":""},{"location":"matrix/matrix_operations/#transpose-of-a-matrix","title":"Transpose of a matrix","text":"<p>Given a matrix of <code>N x N</code> dimension the transpose is calculated as:</p> <pre><code>class MatrixTranspose {\n    public int[][] transpose(int[][] matrix) {\n        int n = matrix.length;\n        for (int i = 0; i &lt; n; ++i) { // for each row\n            for (int j = i; j &lt; n; ++j) { // start from the row's position in column\n                int tmp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = tmp;\n            }\n        }\n    }\n}\n</code></pre> <p>Time Complexity: <code>O(n^2)</code></p>"},{"location":"matrix/matrix_operations/#rotate-image","title":"Rotate Image","text":"<p>To rotate an image matrix by +90 degrees or clockwise:</p> <ul> <li>Tranpose the matrix.</li> <li>Reverse all rows.</li> </ul> <p>To rotate an image matrix by -90 degrees or anti-clockwise:</p> <ul> <li>Tranpose the matrix.</li> <li>Reverse all columns.</li> </ul>"},{"location":"recursion/patterns/backtracking/","title":"Backtracking","text":""},{"location":"recursion/patterns/backtracking/#introduction","title":"Introduction","text":"<p>Backtracking is a strategy where we solve a problem for all possible patterns and stop after receiving the best solution. The base idea to retract our solution to the best possible condition from where other solution can be made of branched is to undo any changes we've made. What I mean by that is the magic of backtracking is to rub out the non-working solution to a point where the solution can be made working again.</p>"},{"location":"recursion/patterns/backtracking/#finding-valid-permutation","title":"Finding valid permutation","text":""},{"location":"recursion/patterns/backtracking/#problem-statement","title":"Problem Statement","text":"<p>Given a string \"ABC\" find out if permutation \"CBA\" is possible from all the characters of the string.</p>"},{"location":"recursion/patterns/backtracking/#solution","title":"Solution","text":"<p>The permutations of string \"ABC\" are {\"ABC\", \"ACB\", \"BCA\", \"BAC\", \"CAB\", \"CBA\"}. As we can see the total number of permutations for \"ABC\" are  which equals . And after generating the permutations \"CBA\" is also a valid permutation.</p> <p>We can solve this problem in a problem by applying backtracking as follows:</p> Java <pre><code>class BacktrackingExample {\npublic static boolean hasPermutation(String text, String pattern) {\n        int[] usedMap = new int[text.length()];\n        return isPermutePossible(text, pattern, \"\", usedMap);\n    }\n\n    public static boolean isPermutePossible(String text, String pattern, String resultText,\n            int[] usedMap) {\n        if (text.length() &gt; pattern.length()) {\n            return false;\n        }\n        if (resultText.length() == text.length()) {\n            if (pattern.equals(resultText)) {\n                return true;\n            }\n        }\n        for (int i = 0; i &lt; text.length(); ++i) {\n            if (usedMap[i] == 0) { // character is not used so far\n                String newResultText = resultText + text.charAt(i);\n                usedMap[i] = 1; // set character as used\n                boolean isPossible = isPermutePossible(text, pattern, newResultText, usedMap);\n                if (isPossible) { // solution is possible\n                    return true; // cut the branch\n                }\n                usedMap[i] = 0; // free character to be used again\n            }\n        }\n        return false;\n    } \n}\n</code></pre>"},{"location":"recursion/patterns/backtracking/#rat-in-a-maze","title":"Rat in a Maze","text":""},{"location":"recursion/patterns/backtracking/#problem-statement_1","title":"Problem Statement","text":"<p>Rat in a Maze. You have maze where the rat is left to wander in the start and is forced to find the path outside of the maze; rat can only move down and right direction. This 2D arrays shows the maze:</p> <pre><code>[[0, 1, 0, 0],\n [0, 0, 1, 0],\n [0, 0, 0, 1],\n [0, 1, 0, 2]]\n</code></pre> <p>The value <code>2</code> in the array is the position where rat can escape or exit the maze. The rat always start at index <code>(0, 0)</code>.</p>"},{"location":"recursion/patterns/backtracking/#solution_1","title":"Solution","text":"Java <pre><code>public class RatInMaze {\n    public boolean canRatEscape(int[][] maze, int start, int end) {\n        int n = maze.length;\n        int m = maze[0].length;\n        if (start == n || end == m || maze[start][end] == 1 || maze[start][end] == 3) {\n            return false;\n        }\n        if (maze[start][end] == 2) { // rat reached the exit in maze\n            return true;\n        }\n        maze[start][end] = 3; // marking visited\n        if (canRatEscape(maze, start + 1, end) || canRatEscape(maze, start, end + 1)) {\n            return true;\n        }\n        maze[start][end] = 0; // unmarking visited so that new solution can be made\n        return false;\n    }\n}\n</code></pre>"},{"location":"recursion/patterns/recursion/","title":"Basic Recursion","text":""},{"location":"recursion/patterns/recursion/#introduction","title":"Introduction","text":"<p>Recursion is a fundamental concept in programming where a function calls itself to solve smaller instances of a problem. It is widely used in algorithms for sorting, searching, dynamic programming, and more. However, understanding recursion can be challenging, especially when it comes to trusting the recursive calls. This is where the Leap of Faith principle comes into play.</p> <p>Recursion occurs when a function calls itself to solve a problem. Every recursive function has two key components:</p> <ol> <li>Base Case: A condition that terminates the recursion.</li> <li>Recursive Case: A call to the same function with a smaller input.</li> </ol>"},{"location":"recursion/patterns/recursion/#example-factorial-function","title":"Example: Factorial Function","text":"<p>The factorial of a number  (denoted as ) is defined as:  </p> <p>This can be implemented as:</p> Java <pre><code>public static int factorial(int n) {\n    if (n == 0) return 1; // Base case\n    return n * factorial(n - 1); // Recursive case\n}\n</code></pre>"},{"location":"recursion/patterns/recursion/#the-leap-of-faith","title":"The Leap of Faith","text":"<p>When working with recursion, it is crucial to trust that the function correctly solves smaller instances. Instead of manually tracing each recursive call, assume that the function works for a smaller value and build upon that assumption.</p>"},{"location":"recursion/patterns/recursion/#applying-the-leap-of-faith-to-factorial","title":"Applying the Leap of Faith to Factorial","text":"<ul> <li>Assume <code>factorial(n-1)</code> correctly computes .</li> <li>Then, <code>factorial(n) = n * (n-1)!</code> must also be correct.</li> </ul> <p>This approach makes reasoning about recursion easier and aligns with mathematical induction.</p>"},{"location":"recursion/patterns/recursion/#example-computing-fibonacci-numbers","title":"Example: Computing Fibonacci Numbers","text":"<p>The Fibonacci sequence is defined as:  </p> <p>Implementation:</p> Java <pre><code>public static int fibonacci(int n) {\n    if (n == 0) return 0; // Base case\n    if (n == 1) return 1; // Base case\n    return fibonacci(n - 1) + fibonacci(n - 2); // Recursive case\n}\n</code></pre> <p>Using the Leap of Faith:</p> <ul> <li>Assume <code>fibonacci(n-1)</code> and <code>fibonacci(n-2)</code> correctly compute  and .</li> <li>Then, <code>fibonacci(n) = fibonacci(n-1) + fibonacci(n-2)</code> must also be correct.</li> </ul> Question <p>Given the root of a binary tree, return the number of the nodes in the tree.</p> <p>Hint:  </p>"},{"location":"recursion/patterns/recursion/#tail-recursion","title":"Tail Recursion","text":"<p>Tail recursion is a special form of recursion where the recursive call is the last operation in the function, allowing for optimizations like tail call elimination.</p>"},{"location":"recursion/patterns/recursion/#example-tail-recursive-factorial","title":"Example: Tail-Recursive Factorial","text":"Java <pre><code>public static int factorialTail(int n, int accumulator) {\n    if (n == 0) return accumulator;\n    return factorialTail(n - 1, n * accumulator);\n}\n\npublic static int factorial(int n) {\n    return factorialTail(n, 1);\n}\n</code></pre> <p>Here, the recursive call does not need extra space on the call stack, improving efficiency.</p>"},{"location":"recursion/patterns/recursion/#use-of-recursion","title":"Use of Recursion","text":"<p>Recursion is useful for problems with a natural recursive structure, such as:</p> <ul> <li>Tree and graph traversal (e.g., Depth-First Search)</li> <li>Divide and conquer algorithms (e.g., Merge Sort, Quick Sort)</li> <li>Dynamic programming (e.g., Fibonacci with memoization)</li> </ul>"},{"location":"tree/algorithms/avl_tree/","title":"Adelson-Velsky and Landis (AVL) Tree","text":""},{"location":"tree/algorithms/avl_tree/#definition","title":"Definition","text":"<p>The BST tree when converted to a height balanced tree then it becomes an AVL Tree. Balancing factor of a tree node is the difference between the heights of the left and right sub tree.</p> <p>For a tree to be height-balanced the factor should belong to a value in the set . More specifically the absolute difference of heights of right and left subtree must be either  or .</p> <pre><code>graph TD;\n    A[30] --&gt;|BF = 1 - 1 = 0| B[20]\n    A --&gt;|BF = 1 - 0 = 1| C[40]\n    B --&gt;|BF=0| D[10]\n    B --&gt;|BF=0| E[25]\n    C --&gt;|BF=0| F[50]</code></pre>"},{"location":"tree/algorithms/avl_tree/#inserting-in-avl","title":"Inserting in AVL","text":""},{"location":"tree/algorithms/binary_search_tree/","title":"Binary Search Tree","text":"<pre><code>graph TD;\n    A[8] --&gt; B[3];\n    A --&gt; C[10];\n    B --&gt; D[1];\n    B --&gt; E[6];\n    E --&gt; F[4];\n    E --&gt; G[7];</code></pre> <p>A binary search tree is a tree where the left child of the tree is always smaller and the right child of the subtree is always greater than the current node. This subsequently prove that on a given root, the left subtree will have children having value lesser than the current root and on the right subtree the children will have greater value than the current root node.</p>"},{"location":"tree/algorithms/binary_search_tree/#inorder-traversal","title":"Inorder Traversal","text":"<p>Inorder traversal of a BST will result in accessing the nodes of the tree in an ascdending order of their values. This is crucial in problems where we have to access the order of the nodes in a particular fashion.</p>"},{"location":"tree/algorithms/binary_search_tree/#insertion-in-a-bst","title":"Insertion in a BST","text":"Java <pre><code>public class BST {\n    public root insert(TreeNode root, int val) {\n        if (root == null) {\n            return new TreeNode(val);\n        }\n        if (root.val &gt; val) {\n            root.left = insert(root.left, val);\n        } else {\n            root.right = insert(root.right, val);\n        }\n        return root;\n    }\n}\n</code></pre>"},{"location":"tree/algorithms/binary_search_tree/#deletion-in-a-bst","title":"Deletion in a BST","text":"Java <pre><code>public class BST {\n    public root delete(TreeNode root, int val) {\n        if (root == null) {\n            // node is not found\n            return null;\n        }\n        if (root.left == null &amp;&amp; root.right == null) {\n            // node is found but is leaf node\n            return null;\n        }\n        if (root.val == val) {\n            if (heightOf(root.left) &gt; heightOf(root.right)) {\n                // find the previous value in in-order traversal\n                TreeNode predecessor = findPredecessor(root.left);\n                root.val = predecessor.val;\n                root.left = delete(root.left, predecessor.val); // delete the previous value\n            } else {\n                // find the next value in the in-order traversal\n                TreeNode successor = findSuccessor(root.right);\n                root.val = successor.val;\n                root.right = delete(root.right, successor.val); // delete the next value\n            }\n        }\n    }\n\n    public int heightOf(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        if (root.left == null &amp;&amp; root.right == null) {\n            return 1;\n        }\n        return 1 + Math.max(heightOf(root.left), heightOf(root.right));\n    }\n\n    public TreeNode findSuccessor(TreeNode root) {\n        TreeNode ptr = root.right;\n        while (ptr.left != null) {\n            ptr = ptr.left;\n        }\n        return ptr;\n    }\n\n    public TreeNode findPredessor(TreeNode root) {\n        TreeNode ptr = root.left;\n        while (ptr.right != null) {\n            ptr = ptr.right;\n        }\n        return ptr;\n    }\n}\n</code></pre>"},{"location":"tree/algorithms/heap/","title":"Binary Heap","text":"<p>A heap is a complete binary tree in which each node in the tree starting from root has value strictly greater than or less than children node's value. An example is shown below which shows max-heap which is a heap where the parent node has strictly greater value than it's child nodes.</p> <pre><code>graph TD\n    A[100] --&gt; B[50]\n    A --&gt; C[30]\n    B --&gt; D[20]\n    B --&gt; E[10]\n    C --&gt; F[15]\n    C --&gt; G[5]</code></pre> <p>Priority Queue is a queue data structure where values are dequeued based on the priority of the elements. The priority can be decided based on the weight or value of the element or some other factor if the element is complex.</p> <p>Heap lets us implement priority queue based on the value of the nodes. If the priority is decided by the value of the element then if the elements are to be dequeued based on maximum value first we implement a Max-Heap and if the elements have to be dequeued based on minimum value first then Min-Heap.</p> <p>Here is an code that we can use to code a priority queue of all the three kinds: min, max and custom. The lamda function is a custom comparator class.</p> Java <pre><code>class PriorityQueueUsage {\n    public static void main(String[] args) {\n        // max-heap or max priority queue\n        PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;();\n        queue.add(1);\n        queue.add(2);\n\n        // min-heap or min priority queue\n        PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;((p1, p2) -&gt; {\n            return -Integer.compare(p1, p2);\n        });\n\n        // custom comparator priority queue\n        PriorityQueue&lt;CustomClass&gt; customHeap = new PriorityQueue&lt;&gt;((p1, p2) -&gt; {\n            return Integer.compare(p1.val, p2.val); // val is a integer attribute\n        });\n    }\n}\n</code></pre>"},{"location":"tree/algorithms/union_find/","title":"Union-Find Algorithm","text":""},{"location":"tree/algorithms/union_find/#union-find-algorithm-for-disjoint-set","title":"Union-Find Algorithm for Disjoint Set","text":"<p>Initialization of parents and ranks:</p> Java <pre><code>class UnionFind {\n    public void initialize(int[] parents, int[] ranks) {\n        int N = parents.length;\n        for (int i = 0; i &lt; N; ++i) {\n            parents[i] = i;\n            ranks[i] = 0;\n        }\n    }\n}\n</code></pre> <p>Find algorithm:</p> Java <pre><code>class UnionFind {\n    public int find(int x, int[] parents) {\n        if (parents[x] == x) {\n            return x;\n        }\n        return find(parents[x], parents);\n    }\n}\n</code></pre> <p>Find Algorithm with Path compression:</p> <p>Why Path compression? Because ultimately we want to reach the root parent of the tree. What if we set the root parent directly for the given element? This way we don't have to traverse the tree to find the root parent.</p> Java <pre><code>class UnionFind {\n    public int find(int x, int[] parent) {\n        if (x == parent[x]) {\n            return x;\n        }\n        parent[x] = find(parent[x], parent); // path compression\n        return parent[x];\n    }\n}\n</code></pre> <p>Union Algorithm:</p> Java <pre><code>class UnionFind {\n    public void union(int x, int y, int[] parents) {\n        int parentX = find(x, parents);\n        int parentY = find(y, parents);\n\n        if (parentX == parentY) {\n            return;\n        }\n\n        parent[parentY] = parentX;\n    }\n}\n</code></pre> <p>Union by Rank Algorithm:</p> <p>Why do we need the ranking? Because with simple Union operation, a chain is formed that takes O(n) time to find the parent in the worst case and then unionize two elements.</p> Java <pre><code>class UnionRankFind {\n    public void union(int x, int y, int[] parents, int[] ranks) {\n        int parentX = find(x, parents);\n        int parentY = find(y, parents);\n\n        if (parentX == parentY) {\n            return;\n        }\n\n        if (ranks[parentX] &gt; ranks[parentY]) { // union based on ranking\n            parents[parentY] = parentX;\n        } else if (ranks[parentY] &gt; ranks[parentX]) {\n            parents[parentX] = parentY;\n        } else {\n            parents[parentY] = parentX;\n            ranks[parentX]++;\n        }\n    }\n}\n</code></pre>"},{"location":"tree/algorithms/union_find/#kruskals-algorithm","title":"Kruskal's Algorithm","text":"<p>With Kruskal's algorithm we find the Minimum Spanning Tree of any Graph. A MST is a graph which has the minimum number of least costly edges which can create a connected graph. In a Kruskal's algorithm we are given an array of edges along with their weights and asked to return an array of edges that are required to create a MST.</p> <p>For the given graph below:</p> <pre><code>graph TD\n    A --10--&gt; B\n    A --15--&gt; C\n    B --5--&gt; C\n    B --10--&gt; D\n    C --20--&gt; D\n    C --25--&gt; E\n    D --15--&gt; E</code></pre> <p>The MST is as follows: <pre><code>graph TD\n    A --10--&gt; B\n    B --5--&gt; C\n    B --10--&gt; D\n    D --15--&gt; E</code></pre></p> <p>Kruskal's Algorithm:</p> Java <pre><code>class Kruskals {\n    // Edge: [src, dest, cost]\n    public List&lt;Edge&gt; kruskalsAlgorithm(Edge[] edges, int totalNodes) {\n        List&lt;Edge&gt; mst = new ArrayList&lt;&gt;();\n        int totalProcessedNode = 1;\n        int[] parent = new int[totalNodes];\n        int[] rank = new int[totalNodes];\n        for (int i = 0; i &lt; totalNodes; ++i) {\n            parent[i] = i;\n        }\n\n        Arrays.sort(edges, (e1, e2) -&gt; e1[2] - e2[2]); // sorting array based on cost\n        for (int i = 0; i &lt; edges.length &amp;&amp; totalProcessedNodes != totalNodes; ++i) {\n            Edge e = edges[i];\n            int src = e[0];\n            int dest = e[1];\n            if (find(src, parent) == find(dest, parent)) {\n                continue; // ignore if edge was already added\n            }\n            totalProcessedNode++;\n            union(src, dest, parent, rank);\n            mst.add(e);\n        }\n        return mst;\n    }\n\n    private void union(int src, int dest, int[] parent, int[] rank) {\n        if (find(src, parent) == find(dest, parent)) {\n            return;\n        }\n        parSrc = find(src, parent);\n        parDest = find(dest, parent);\n        if (rank[parSrc] &gt; rank[parDest]) {\n            parent[parDest] = parSrc;\n        } else if (rank[parDest] &gt; rank[parSrc]) {\n            parent[parSrc] = parDest;\n        } else {\n            parent[parDest] = parSrc;\n            rank[parSrc]++;\n        }\n    }\n\n    private int find(int src, int[] parent) {\n        if (src == parent[src]) {\n            return src;\n        }\n        parent[src] = find(parent[src], parent);\n        return parent[src];\n    }\n}\n</code></pre>"},{"location":"tricks_in_java/lambda_stream/","title":"Tricks with Lambda Expression and Streams","text":""},{"location":"tricks_in_java/lambda_stream/#collect-objects-from-an-arraylist-to-another-based-on-some-condition","title":"Collect objects from an arraylist to another based on some condition","text":"<pre><code>public class Trick1 {\n    public static void main(String[] args) {\n        List&lt;Pair&gt; oldList = new ArrayList&lt;&gt;();\n        oldList.add(new Pair(1, 2));\n        oldList.add(new Pair(0, 2));\n        oldList.add(new Pair(3, 2));\n        oldList.add(new Pair(4, 3));\n\n        // collect all pairs having x &gt;= 1\n        List&lt;Pair&gt; newList = oldList.stream().\n            .collect(Collectors.filtering(p -&gt; p.x &gt;= 1, Collectors.toList()));\n    }\n\n    static class Pair {\n        public int x;\n        public int y;\n\n        public Pair(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n}\n</code></pre>"}]}