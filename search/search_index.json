{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"backtracking/backtracking/","text":"Backtracking Backtracking is a strategy where we solve a problem for all possible patterns and stop after receiving the best solution. The base idea to retract our solution to the best possible condition from where other solution can be made of branched is to undo any changes we've made. What I mean by that is the magic of backtracking is to rub out the non-working solution to a point where the solution can be made working again. Finding valid permutation Problem Given a string \"ABC\" find out if permutation \"CBA\" is possible from all the characters of the string. Solution The permutations of string \"ABC\" are {\"ABC\", \"ACB\", \"BCA\", \"BAC\", \"CAB\", \"CBA\"}. As we can see the total number of permutations for \"ABC\" are Factorial(3) which equals 6 . And after generating the permutations \"CBA\" is also a valid permutation. We can solve this problem in a problem by applying backtracking as follows: class BacktrackingExample { public static boolean hasPermutation(String text, String pattern) { int[] usedMap = new int[text.length()]; return isPermutePossible(text, pattern, \"\", usedMap); } public static boolean isPermutePossible(String text, String pattern, String resultText, int[] usedMap) { if (text.length() > pattern.length()) { return false; } if (resultText.length() == text.length()) { if (pattern.equals(resultText)) { return true; } } for (int i = 0; i < text.length(); ++i) { if (usedMap[i] == 0) { // character is not used so far String newResultText = resultText + text.charAt(i); usedMap[i] = 1; // set character as used boolean isPossible = isPermutePossible(text, pattern, newResultText, usedMap); if (isPossible) { // solution is possible return true; // cut the branch } usedMap[i] = 0; // free character to be used again } } return false; } } Problem Rat in a Maze. You have maze where the rat is left to wander in the start and is forced to find the path outside of the maze; rat can only move down and right direction. This 2D arrays shows the maze: [[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [0, 1, 0, 2]] The value 2 in the array is the position where rat can escape or exit the maze. The rat always start at index (0, 0) . Solution public class RatInMaze { public boolean canRatEscape(int[][] maze, int start, int end) { int n = maze.length; int m = maze[0].length; if (start == n || end == m || maze[start][end] == 1 || maze[start][end] == 3) { return false; } if (maze[start][end] == 2) { // rat reached the exit in maze return true; } maze[start][end] = 3; // marking visited if (canRatEscape(maze, start + 1, end) || canRatEscape(maze, start, end + 1)) { return true; } maze[start][end] = 0; // unmarking visited so that new solution can be made return false; } }","title":"Backtracking"},{"location":"backtracking/backtracking/#backtracking","text":"Backtracking is a strategy where we solve a problem for all possible patterns and stop after receiving the best solution. The base idea to retract our solution to the best possible condition from where other solution can be made of branched is to undo any changes we've made. What I mean by that is the magic of backtracking is to rub out the non-working solution to a point where the solution can be made working again.","title":"Backtracking"},{"location":"backtracking/backtracking/#finding-valid-permutation","text":"","title":"Finding valid permutation"},{"location":"backtracking/backtracking/#problem","text":"Given a string \"ABC\" find out if permutation \"CBA\" is possible from all the characters of the string.","title":"Problem"},{"location":"backtracking/backtracking/#solution","text":"The permutations of string \"ABC\" are {\"ABC\", \"ACB\", \"BCA\", \"BAC\", \"CAB\", \"CBA\"}. As we can see the total number of permutations for \"ABC\" are Factorial(3) which equals 6 . And after generating the permutations \"CBA\" is also a valid permutation. We can solve this problem in a problem by applying backtracking as follows: class BacktrackingExample { public static boolean hasPermutation(String text, String pattern) { int[] usedMap = new int[text.length()]; return isPermutePossible(text, pattern, \"\", usedMap); } public static boolean isPermutePossible(String text, String pattern, String resultText, int[] usedMap) { if (text.length() > pattern.length()) { return false; } if (resultText.length() == text.length()) { if (pattern.equals(resultText)) { return true; } } for (int i = 0; i < text.length(); ++i) { if (usedMap[i] == 0) { // character is not used so far String newResultText = resultText + text.charAt(i); usedMap[i] = 1; // set character as used boolean isPossible = isPermutePossible(text, pattern, newResultText, usedMap); if (isPossible) { // solution is possible return true; // cut the branch } usedMap[i] = 0; // free character to be used again } } return false; } }","title":"Solution"},{"location":"backtracking/backtracking/#problem_1","text":"Rat in a Maze. You have maze where the rat is left to wander in the start and is forced to find the path outside of the maze; rat can only move down and right direction. This 2D arrays shows the maze: [[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [0, 1, 0, 2]] The value 2 in the array is the position where rat can escape or exit the maze. The rat always start at index (0, 0) .","title":"Problem"},{"location":"backtracking/backtracking/#solution_1","text":"public class RatInMaze { public boolean canRatEscape(int[][] maze, int start, int end) { int n = maze.length; int m = maze[0].length; if (start == n || end == m || maze[start][end] == 1 || maze[start][end] == 3) { return false; } if (maze[start][end] == 2) { // rat reached the exit in maze return true; } maze[start][end] = 3; // marking visited if (canRatEscape(maze, start + 1, end) || canRatEscape(maze, start, end + 1)) { return true; } maze[start][end] = 0; // unmarking visited so that new solution can be made return false; } }","title":"Solution"},{"location":"disjoint_set/union_find/","text":"Union-Find Algorithm for Disjoint Set Initialization of parents and ranks : class UnionFind { public void initialize(int[] parents, int[] ranks) { int N = parents.length; for (int i = 0; i < N; ++i) { parents[i] = i; ranks[i] = 0; } } } Find algorithm : class UnionFind { public int find(int x, int[] parents) { if (parents[x] == x) { return x; } return find(parents[x], parents); } } Find Algorithm with Path compression : Why Path compression? Because ultimately we want to reach the root parent of the tree. What if we set the root parent directly for the given element? This way we don't have to traverse the tree to find the root parent. class UnionFind { public int find(int x, int[] parent) { if (x == parent[x]) { return x; } parent[x] = find(parent[x], parent); // path compression return parent[x]; } } Union Algorithm : class UnionFind { public void union(int x, int y, int[] parents) { int parentX = find(x, parents); int parentY = find(y, parents); if (parentX == parentY) { return; } parent[parentY] = parentX; } } Union by Rank Algorithm : Why do we need the ranking? Because with simple Union operation, a chain is formed that takes O(n) time to find the parent in the worst case and then unionize two elements. class UnionRankFind { public void union(int x, int y, int[] parents, int[] ranks) { int parentX = find(x, parents); int parentY = find(y, parents); if (parentX == parentY) { return; } if (ranks[parentX] > ranks[parentY]) { // union based on ranking parents[parentY] = parentX; } else if (ranks[parentY] > ranks[parentX]) { parents[parentX] = parentY; } else { parents[parentY] = parentX; ranks[parentX]++; } } } Kruskal's Algorithm With Kruskal's algorithm we find the Minimum Spanning Tree of any Graph. A MST is a graph which has the minimum number of least costly edges which can create a connected graph. In a Kruskal's algorithm we are given an array of edges along with their weights and asked to return an array of edges that are required to create a MST. For the given graph below: graph TD A --10--> B A --15--> C B --5--> C B --10--> D C --20--> D C --25--> E D --15--> E The MST is as follows: graph TD A --10--> B B --5--> C B --10--> D D --15--> E Kruskal's Algorithm : class Kruskals { // Edge: [src, dest, cost] public List<Edge> kruskalsAlgorithm(Edge[] edges, int totalNodes) { List<Edge> mst = new ArrayList<>(); int totalProcessedNode = 1; int[] parent = new int[totalNodes]; int[] rank = new int[totalNodes]; for (int i = 0; i < totalNodes; ++i) { parent[i] = i; } Arrays.sort(edges, (e1, e2) -> e1[2] - e2[2]); // sorting array based on cost for (int i = 0; i < edges.length && totalProcessedNodes != totalNodes; ++i) { Edge e = edges[i]; int src = e[0]; int dest = e[1]; if (find(src, parent) == find(dest, parent)) { continue; // ignore if edge was already added } totalProcessedNode++; union(src, dest, parent, rank); mst.add(e); } return mst; } private void union(int src, int dest, int[] parent, int[] rank) { if (find(src, parent) == find(dest, parent)) { return; } parSrc = find(src, parent); parDest = find(dest, parent); if (rank[parSrc] > rank[parDest]) { parent[parDest] = parSrc; } else if (rank[parDest] > rank[parSrc]) { parent[parSrc] = parDest; } else { parent[parDest] = parSrc; rank[parSrc]++; } } private int find(int src, int[] parent) { if (src == parent[src]) { return src; } parent[src] = find(parent[src], parent); return parent[src]; } }","title":"Union-Find Algorithm"},{"location":"disjoint_set/union_find/#union-find-algorithm-for-disjoint-set","text":"Initialization of parents and ranks : class UnionFind { public void initialize(int[] parents, int[] ranks) { int N = parents.length; for (int i = 0; i < N; ++i) { parents[i] = i; ranks[i] = 0; } } } Find algorithm : class UnionFind { public int find(int x, int[] parents) { if (parents[x] == x) { return x; } return find(parents[x], parents); } } Find Algorithm with Path compression : Why Path compression? Because ultimately we want to reach the root parent of the tree. What if we set the root parent directly for the given element? This way we don't have to traverse the tree to find the root parent. class UnionFind { public int find(int x, int[] parent) { if (x == parent[x]) { return x; } parent[x] = find(parent[x], parent); // path compression return parent[x]; } } Union Algorithm : class UnionFind { public void union(int x, int y, int[] parents) { int parentX = find(x, parents); int parentY = find(y, parents); if (parentX == parentY) { return; } parent[parentY] = parentX; } } Union by Rank Algorithm : Why do we need the ranking? Because with simple Union operation, a chain is formed that takes O(n) time to find the parent in the worst case and then unionize two elements. class UnionRankFind { public void union(int x, int y, int[] parents, int[] ranks) { int parentX = find(x, parents); int parentY = find(y, parents); if (parentX == parentY) { return; } if (ranks[parentX] > ranks[parentY]) { // union based on ranking parents[parentY] = parentX; } else if (ranks[parentY] > ranks[parentX]) { parents[parentX] = parentY; } else { parents[parentY] = parentX; ranks[parentX]++; } } }","title":"Union-Find Algorithm for Disjoint Set"},{"location":"disjoint_set/union_find/#kruskals-algorithm","text":"With Kruskal's algorithm we find the Minimum Spanning Tree of any Graph. A MST is a graph which has the minimum number of least costly edges which can create a connected graph. In a Kruskal's algorithm we are given an array of edges along with their weights and asked to return an array of edges that are required to create a MST. For the given graph below: graph TD A --10--> B A --15--> C B --5--> C B --10--> D C --20--> D C --25--> E D --15--> E The MST is as follows: graph TD A --10--> B B --5--> C B --10--> D D --15--> E Kruskal's Algorithm : class Kruskals { // Edge: [src, dest, cost] public List<Edge> kruskalsAlgorithm(Edge[] edges, int totalNodes) { List<Edge> mst = new ArrayList<>(); int totalProcessedNode = 1; int[] parent = new int[totalNodes]; int[] rank = new int[totalNodes]; for (int i = 0; i < totalNodes; ++i) { parent[i] = i; } Arrays.sort(edges, (e1, e2) -> e1[2] - e2[2]); // sorting array based on cost for (int i = 0; i < edges.length && totalProcessedNodes != totalNodes; ++i) { Edge e = edges[i]; int src = e[0]; int dest = e[1]; if (find(src, parent) == find(dest, parent)) { continue; // ignore if edge was already added } totalProcessedNode++; union(src, dest, parent, rank); mst.add(e); } return mst; } private void union(int src, int dest, int[] parent, int[] rank) { if (find(src, parent) == find(dest, parent)) { return; } parSrc = find(src, parent); parDest = find(dest, parent); if (rank[parSrc] > rank[parDest]) { parent[parDest] = parSrc; } else if (rank[parDest] > rank[parSrc]) { parent[parSrc] = parDest; } else { parent[parDest] = parSrc; rank[parSrc]++; } } private int find(int src, int[] parent) { if (src == parent[src]) { return src; } parent[src] = find(parent[src], parent); return parent[src]; } }","title":"Kruskal's Algorithm"},{"location":"graph/detect_cycle_in_directed_graph/","text":"Detect Cycle in Directed Graph Given a directed graph represented as an adjacency list, the task is to determine if the graph contains any cycles. graph LR 1 --> 2 2 --> 3 3 --> 4 4 --> 2 Depth-First Search (DFS) Approach In an undirected graph , we use a visited[] array to track visited nodes and detect if a node is revisited, indicating a cycle. However, this approach does not work for directed graphs because nodes can be visited multiple times from different paths. For example, consider the following graph: graph LR 1 --> 2 3 --> 2 Here, node 2 can be visited twice, but that does not imply the presence of a cycle. Observing Sub-Graphs A directed graph can be seen as a collection of sub-graphs. In the graph above, there are two sub-graphs: 1 \u2192 2 and 3 \u2192 2 . Running a cycle detection algorithm independently on each sub-graph will detect cycles. For instance: for (each node in graph): new visited[]; if (detectCycle(node, visited, graph)): return true; While this approach works, it is inefficient as it repeatedly initializes the visited[] array and performs redundant checks. Optimized DFS Algorithm We can optimize the approach by: 1. Initializing the visited[] array once. 2. Introducing a processed[] array to track sub-graphs already checked for cycles. Here\u2019s the code: def detectCycle(graph): visited = [False] * len(graph) processed = [False] * len(graph) for node in range(len(graph)): if not processed[node]: if detectCycleUtil(node, graph, visited, processed): return True return False def detectCycleUtil(node, graph, visited, processed): visited[node] = True processed[node] = True for nbr in graph[node]: if visited[nbr]: # Cycle detected return True elif detectCycleUtil(nbr, graph, visited, processed): return True visited[node] = False return False visited[] : Tracks nodes visited in the current DFS traversal. processed[] : Tracks sub-graphs already checked for cycles. Breadth-First Search (BFS) Approach To understand the BFS-based approach, it\u2019s essential to first understand topological sorting for directed graphs. Consider the graph below: graph LR 1 --> 2 2 --> 3 3 --> 4 1 --> 4 This graph can be viewed as a dependency graph, where processing node 1 requires processing nodes 2 , 3 , and 4 first. The topological order of the graph reflects this dependency. Topological Sorting Algorithm Topological sorting processes nodes in decreasing order of their in-degrees . Below is the algorithm to print the topological order of a directed graph: def topological_sort(graph): indegrees = [0] * len(graph) # Compute in-degrees of all nodes for node in range(len(graph)): for nbr in graph[node]: indegrees[nbr] += 1 queue = [] for node in range(len(graph)): if indegrees[node] == 0: # Add nodes with 0 in-degree queue.append(node) while queue: n = queue.pop(0) print(n) # Process node for nbr in graph[n]: indegrees[nbr] -= 1 # Decrement in-degree if indegrees[nbr] == 0: queue.append(n) Khan's Algorithm for Cycle Detection Khan's algorithm is a modification of the topological sorting algorithm. By counting the nodes added to the queue, we can determine if the graph contains a cycle. If the count of processed nodes equals the total number of nodes in the graph, it implies the absence of cycles. def detect_cycle(graph): indegrees = [0] * len(graph) # Compute in-degrees of all nodes for node in range(len(graph)): for nbr in graph[node]: indegrees[nbr] += 1 queue = [] count = 0 for node in range(len(graph)): if indegrees[node] == 0: queue.append(node) count += 1 while queue: n = queue.pop(0) for nbr in graph[n]: indegrees[nbr] -= 1 if indegrees[nbr] == 0: queue.append(nbr) count += 1 return count != len(graph) If count == len(graph) : No cycle exists. If count != len(graph) : A cycle is present. Related Problems \ud83d\udcd5 Leetcode - 207. Course Schedule Leetcode - 2392. Build a Matrix With Conditions","title":"Detect Cycle in Directed Graph"},{"location":"graph/detect_cycle_in_directed_graph/#detect-cycle-in-directed-graph","text":"Given a directed graph represented as an adjacency list, the task is to determine if the graph contains any cycles. graph LR 1 --> 2 2 --> 3 3 --> 4 4 --> 2","title":"Detect Cycle in Directed Graph"},{"location":"graph/detect_cycle_in_directed_graph/#depth-first-search-dfs-approach","text":"In an undirected graph , we use a visited[] array to track visited nodes and detect if a node is revisited, indicating a cycle. However, this approach does not work for directed graphs because nodes can be visited multiple times from different paths. For example, consider the following graph: graph LR 1 --> 2 3 --> 2 Here, node 2 can be visited twice, but that does not imply the presence of a cycle.","title":"Depth-First Search (DFS) Approach"},{"location":"graph/detect_cycle_in_directed_graph/#observing-sub-graphs","text":"A directed graph can be seen as a collection of sub-graphs. In the graph above, there are two sub-graphs: 1 \u2192 2 and 3 \u2192 2 . Running a cycle detection algorithm independently on each sub-graph will detect cycles. For instance: for (each node in graph): new visited[]; if (detectCycle(node, visited, graph)): return true; While this approach works, it is inefficient as it repeatedly initializes the visited[] array and performs redundant checks.","title":"Observing Sub-Graphs"},{"location":"graph/detect_cycle_in_directed_graph/#optimized-dfs-algorithm","text":"We can optimize the approach by: 1. Initializing the visited[] array once. 2. Introducing a processed[] array to track sub-graphs already checked for cycles. Here\u2019s the code: def detectCycle(graph): visited = [False] * len(graph) processed = [False] * len(graph) for node in range(len(graph)): if not processed[node]: if detectCycleUtil(node, graph, visited, processed): return True return False def detectCycleUtil(node, graph, visited, processed): visited[node] = True processed[node] = True for nbr in graph[node]: if visited[nbr]: # Cycle detected return True elif detectCycleUtil(nbr, graph, visited, processed): return True visited[node] = False return False visited[] : Tracks nodes visited in the current DFS traversal. processed[] : Tracks sub-graphs already checked for cycles.","title":"Optimized DFS Algorithm"},{"location":"graph/detect_cycle_in_directed_graph/#breadth-first-search-bfs-approach","text":"To understand the BFS-based approach, it\u2019s essential to first understand topological sorting for directed graphs. Consider the graph below: graph LR 1 --> 2 2 --> 3 3 --> 4 1 --> 4 This graph can be viewed as a dependency graph, where processing node 1 requires processing nodes 2 , 3 , and 4 first. The topological order of the graph reflects this dependency.","title":"Breadth-First Search (BFS) Approach"},{"location":"graph/detect_cycle_in_directed_graph/#topological-sorting-algorithm","text":"Topological sorting processes nodes in decreasing order of their in-degrees . Below is the algorithm to print the topological order of a directed graph: def topological_sort(graph): indegrees = [0] * len(graph) # Compute in-degrees of all nodes for node in range(len(graph)): for nbr in graph[node]: indegrees[nbr] += 1 queue = [] for node in range(len(graph)): if indegrees[node] == 0: # Add nodes with 0 in-degree queue.append(node) while queue: n = queue.pop(0) print(n) # Process node for nbr in graph[n]: indegrees[nbr] -= 1 # Decrement in-degree if indegrees[nbr] == 0: queue.append(n)","title":"Topological Sorting Algorithm"},{"location":"graph/detect_cycle_in_directed_graph/#khans-algorithm-for-cycle-detection","text":"Khan's algorithm is a modification of the topological sorting algorithm. By counting the nodes added to the queue, we can determine if the graph contains a cycle. If the count of processed nodes equals the total number of nodes in the graph, it implies the absence of cycles. def detect_cycle(graph): indegrees = [0] * len(graph) # Compute in-degrees of all nodes for node in range(len(graph)): for nbr in graph[node]: indegrees[nbr] += 1 queue = [] count = 0 for node in range(len(graph)): if indegrees[node] == 0: queue.append(node) count += 1 while queue: n = queue.pop(0) for nbr in graph[n]: indegrees[nbr] -= 1 if indegrees[nbr] == 0: queue.append(nbr) count += 1 return count != len(graph) If count == len(graph) : No cycle exists. If count != len(graph) : A cycle is present.","title":"Khan's Algorithm for Cycle Detection"},{"location":"graph/detect_cycle_in_directed_graph/#related-problems","text":"Leetcode - 207. Course Schedule Leetcode - 2392. Build a Matrix With Conditions","title":"Related Problems \ud83d\udcd5"},{"location":"heap/priority_queue/","text":"Priority Queue (Max/Min Heap) A heap is a complete binary tree in which each node in the tree starting from root has value strictly greater than or less than children node's value. An example is shown below which shows max-heap which is a heap where the parent node has strictly greater value than it's child nodes. graph TD A[100] --> B[50] A --> C[30] B --> D[20] B --> E[10] C --> F[15] C --> G[5] Priority Queue is a queue data structure where values are dequeued based on the priority of the elements. The priority can be decided based on the weight or value of the element or some other factor if the element is complex. Heap lets us implement priority queue based on the value of the nodes. If the priority is decided by the value of the element then if the elements are to be dequeued based on maximum value first we implement a Max-Heap and if the elements have to be dequeued based on minimum value first then Min-Heap. Usage of Priority Queue in Java Here is an example of java code that we can use to code a priority queue of all the three kinds: min, max and custom. The lamda function is a custom comparator class. class PriorityQueueUsage { public static void main(String[] args) { // max-heap or max priority queue PriorityQueue<Integer> maxHeap = new PriorityQueue<>(); queue.add(1); queue.add(2); // min-heap or min priority queue PriorityQueue<Integer> minHeap = new PriorityQueue<>((p1, p2) -> { return -Integer.compare(p1, p2); }); // custom comparator priority queue PriorityQueue<CustomClass> customHeap = new PriorityQueue<>((p1, p2) -> { return Integer.compare(p1.val, p2.val); // val is a integer attribute }); } }","title":"Priority Queue"},{"location":"heap/priority_queue/#priority-queue-maxmin-heap","text":"A heap is a complete binary tree in which each node in the tree starting from root has value strictly greater than or less than children node's value. An example is shown below which shows max-heap which is a heap where the parent node has strictly greater value than it's child nodes. graph TD A[100] --> B[50] A --> C[30] B --> D[20] B --> E[10] C --> F[15] C --> G[5] Priority Queue is a queue data structure where values are dequeued based on the priority of the elements. The priority can be decided based on the weight or value of the element or some other factor if the element is complex. Heap lets us implement priority queue based on the value of the nodes. If the priority is decided by the value of the element then if the elements are to be dequeued based on maximum value first we implement a Max-Heap and if the elements have to be dequeued based on minimum value first then Min-Heap.","title":"Priority Queue (Max/Min Heap)"},{"location":"heap/priority_queue/#usage-of-priority-queue-in-java","text":"Here is an example of java code that we can use to code a priority queue of all the three kinds: min, max and custom. The lamda function is a custom comparator class. class PriorityQueueUsage { public static void main(String[] args) { // max-heap or max priority queue PriorityQueue<Integer> maxHeap = new PriorityQueue<>(); queue.add(1); queue.add(2); // min-heap or min priority queue PriorityQueue<Integer> minHeap = new PriorityQueue<>((p1, p2) -> { return -Integer.compare(p1, p2); }); // custom comparator priority queue PriorityQueue<CustomClass> customHeap = new PriorityQueue<>((p1, p2) -> { return Integer.compare(p1.val, p2.val); // val is a integer attribute }); } }","title":"Usage of Priority Queue in Java"},{"location":"math/formulas/","text":"Greatest Common Divisor class GCD { public int gcd(int a, int b) { if (b == 0) { return a; } return (b, a % b); } public int gcdIter(int a, int b) { while (a != b) { if (a > b) { a = a - b; } else { b = b - a; } } return a; } }","title":"Formulas"},{"location":"math/formulas/#greatest-common-divisor","text":"class GCD { public int gcd(int a, int b) { if (b == 0) { return a; } return (b, a % b); } public int gcdIter(int a, int b) { while (a != b) { if (a > b) { a = a - b; } else { b = b - a; } } return a; } }","title":"Greatest Common Divisor"},{"location":"matrix/matrix_operations/","text":"Transpose of a matrix Given a matrix of N x N dimension the transpose is calculated as: class MatrixTranspose { public int[][] transpose(int[][] matrix) { int n = matrix.length; for (int i = 0; i < n; ++i) { // for each row for (int j = i; j < n; ++j) { // start from the row's position in column int tmp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = tmp; } } } } Time Complexity : O(n^2) Rotate Image To rotate an image matrix by +90 degrees or clockwise: Tranpose the matrix. Reverse all rows. To rotate an image matrix by -90 degrees or anti-clockwise: Tranpose the matrix. Reverse all columns.","title":"Operations on Matrices"},{"location":"matrix/matrix_operations/#transpose-of-a-matrix","text":"Given a matrix of N x N dimension the transpose is calculated as: class MatrixTranspose { public int[][] transpose(int[][] matrix) { int n = matrix.length; for (int i = 0; i < n; ++i) { // for each row for (int j = i; j < n; ++j) { // start from the row's position in column int tmp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = tmp; } } } } Time Complexity : O(n^2)","title":"Transpose of a matrix"},{"location":"matrix/matrix_operations/#rotate-image","text":"To rotate an image matrix by +90 degrees or clockwise: Tranpose the matrix. Reverse all rows. To rotate an image matrix by -90 degrees or anti-clockwise: Tranpose the matrix. Reverse all columns.","title":"Rotate Image"},{"location":"tricks_in_java/lambda_stream/","text":"Tricks with Lambda Expression and Streams Collect objects from an arraylist to another based on some condition public class Trick1 { public static void main(String[] args) { List<Pair> oldList = new ArrayList<>(); oldList.add(new Pair(1, 2)); oldList.add(new Pair(0, 2)); oldList.add(new Pair(3, 2)); oldList.add(new Pair(4, 3)); // collect all pairs having x >= 1 List<Pair> newList = oldList.stream(). .collect(Collectors.filtering(p -> p.x >= 1, Collectors.toList())); } static class Pair { public int x; public int y; public Pair(int x, int y) { this.x = x; this.y = y; } } }","title":"Lamda Expression & Streams"},{"location":"tricks_in_java/lambda_stream/#tricks-with-lambda-expression-and-streams","text":"","title":"Tricks with Lambda Expression and Streams"},{"location":"tricks_in_java/lambda_stream/#collect-objects-from-an-arraylist-to-another-based-on-some-condition","text":"public class Trick1 { public static void main(String[] args) { List<Pair> oldList = new ArrayList<>(); oldList.add(new Pair(1, 2)); oldList.add(new Pair(0, 2)); oldList.add(new Pair(3, 2)); oldList.add(new Pair(4, 3)); // collect all pairs having x >= 1 List<Pair> newList = oldList.stream(). .collect(Collectors.filtering(p -> p.x >= 1, Collectors.toList())); } static class Pair { public int x; public int y; public Pair(int x, int y) { this.x = x; this.y = y; } } }","title":"Collect objects from an arraylist to another based on some condition"}]}