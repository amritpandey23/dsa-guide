{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"graph/detect_cycle_in_directed_graph/","text":"Detect Cycle in Directed Graph Given a directed graph represented as an adjacency list, the task is to determine if the graph contains any cycles. graph LR 1 --> 2 2 --> 3 3 --> 4 4 --> 2 Depth-First Search (DFS) Approach In an undirected graph , we use a visited[] array to track visited nodes and detect if a node is revisited, indicating a cycle. However, this approach does not work for directed graphs because nodes can be visited multiple times from different paths. For example, consider the following graph: graph LR 1 --> 2 3 --> 2 Here, node 2 can be visited twice, but that does not imply the presence of a cycle. Observing Sub-Graphs A directed graph can be seen as a collection of sub-graphs. In the graph above, there are two sub-graphs: 1 \u2192 2 and 3 \u2192 2 . Running a cycle detection algorithm independently on each sub-graph will detect cycles. For instance: for (each node in graph): new visited[]; if (detectCycle(node, visited, graph)): return true; While this approach works, it is inefficient as it repeatedly initializes the visited[] array and performs redundant checks. Optimized DFS Algorithm We can optimize the approach by: 1. Initializing the visited[] array once. 2. Introducing a processed[] array to track sub-graphs already checked for cycles. Here\u2019s the code: def detectCycle(graph): visited = [False] * len(graph) processed = [False] * len(graph) for node in range(len(graph)): if not processed[node]: if detectCycleUtil(node, graph, visited, processed): return True return False def detectCycleUtil(node, graph, visited, processed): visited[node] = True processed[node] = True for nbr in graph[node]: if visited[nbr]: # Cycle detected return True elif detectCycleUtil(nbr, graph, visited, processed): return True visited[node] = False return False visited[] : Tracks nodes visited in the current DFS traversal. processed[] : Tracks sub-graphs already checked for cycles. Breadth-First Search (BFS) Approach To understand the BFS-based approach, it\u2019s essential to first understand topological sorting for directed graphs. Consider the graph below: graph LR 1 --> 2 2 --> 3 3 --> 4 1 --> 4 This graph can be viewed as a dependency graph, where processing node 1 requires processing nodes 2 , 3 , and 4 first. The topological order of the graph reflects this dependency. Topological Sorting Algorithm Topological sorting processes nodes in decreasing order of their in-degrees . Below is the algorithm to print the topological order of a directed graph: def topological_sort(graph): indegrees = [0] * len(graph) # Compute in-degrees of all nodes for node in range(len(graph)): for nbr in graph[node]: indegrees[nbr] += 1 queue = [] for node in range(len(graph)): if indegrees[node] == 0: # Add nodes with 0 in-degree queue.append(node) while queue: n = queue.pop(0) print(n) # Process node for nbr in graph[n]: indegrees[nbr] -= 1 # Decrement in-degree if indegrees[nbr] == 0: queue.append(n) Khan's Algorithm for Cycle Detection Khan's algorithm is a modification of the topological sorting algorithm. By counting the nodes added to the queue, we can determine if the graph contains a cycle. If the count of processed nodes equals the total number of nodes in the graph, it implies the absence of cycles. def detect_cycle(graph): indegrees = [0] * len(graph) # Compute in-degrees of all nodes for node in range(len(graph)): for nbr in graph[node]: indegrees[nbr] += 1 queue = [] count = 0 for node in range(len(graph)): if indegrees[node] == 0: queue.append(node) count += 1 while queue: n = queue.pop(0) for nbr in graph[n]: indegrees[nbr] -= 1 if indegrees[nbr] == 0: queue.append(nbr) count += 1 return count != len(graph) If count == len(graph) : No cycle exists. If count != len(graph) : A cycle is present. Related Problems \ud83d\udcd5 Leetcode - 207. Course Schedule Leetcode - 2392. Build a Matrix With Conditions","title":"Detect Cycle in Directed Graph"},{"location":"graph/detect_cycle_in_directed_graph/#detect-cycle-in-directed-graph","text":"Given a directed graph represented as an adjacency list, the task is to determine if the graph contains any cycles. graph LR 1 --> 2 2 --> 3 3 --> 4 4 --> 2","title":"Detect Cycle in Directed Graph"},{"location":"graph/detect_cycle_in_directed_graph/#depth-first-search-dfs-approach","text":"In an undirected graph , we use a visited[] array to track visited nodes and detect if a node is revisited, indicating a cycle. However, this approach does not work for directed graphs because nodes can be visited multiple times from different paths. For example, consider the following graph: graph LR 1 --> 2 3 --> 2 Here, node 2 can be visited twice, but that does not imply the presence of a cycle.","title":"Depth-First Search (DFS) Approach"},{"location":"graph/detect_cycle_in_directed_graph/#observing-sub-graphs","text":"A directed graph can be seen as a collection of sub-graphs. In the graph above, there are two sub-graphs: 1 \u2192 2 and 3 \u2192 2 . Running a cycle detection algorithm independently on each sub-graph will detect cycles. For instance: for (each node in graph): new visited[]; if (detectCycle(node, visited, graph)): return true; While this approach works, it is inefficient as it repeatedly initializes the visited[] array and performs redundant checks.","title":"Observing Sub-Graphs"},{"location":"graph/detect_cycle_in_directed_graph/#optimized-dfs-algorithm","text":"We can optimize the approach by: 1. Initializing the visited[] array once. 2. Introducing a processed[] array to track sub-graphs already checked for cycles. Here\u2019s the code: def detectCycle(graph): visited = [False] * len(graph) processed = [False] * len(graph) for node in range(len(graph)): if not processed[node]: if detectCycleUtil(node, graph, visited, processed): return True return False def detectCycleUtil(node, graph, visited, processed): visited[node] = True processed[node] = True for nbr in graph[node]: if visited[nbr]: # Cycle detected return True elif detectCycleUtil(nbr, graph, visited, processed): return True visited[node] = False return False visited[] : Tracks nodes visited in the current DFS traversal. processed[] : Tracks sub-graphs already checked for cycles.","title":"Optimized DFS Algorithm"},{"location":"graph/detect_cycle_in_directed_graph/#breadth-first-search-bfs-approach","text":"To understand the BFS-based approach, it\u2019s essential to first understand topological sorting for directed graphs. Consider the graph below: graph LR 1 --> 2 2 --> 3 3 --> 4 1 --> 4 This graph can be viewed as a dependency graph, where processing node 1 requires processing nodes 2 , 3 , and 4 first. The topological order of the graph reflects this dependency.","title":"Breadth-First Search (BFS) Approach"},{"location":"graph/detect_cycle_in_directed_graph/#topological-sorting-algorithm","text":"Topological sorting processes nodes in decreasing order of their in-degrees . Below is the algorithm to print the topological order of a directed graph: def topological_sort(graph): indegrees = [0] * len(graph) # Compute in-degrees of all nodes for node in range(len(graph)): for nbr in graph[node]: indegrees[nbr] += 1 queue = [] for node in range(len(graph)): if indegrees[node] == 0: # Add nodes with 0 in-degree queue.append(node) while queue: n = queue.pop(0) print(n) # Process node for nbr in graph[n]: indegrees[nbr] -= 1 # Decrement in-degree if indegrees[nbr] == 0: queue.append(n)","title":"Topological Sorting Algorithm"},{"location":"graph/detect_cycle_in_directed_graph/#khans-algorithm-for-cycle-detection","text":"Khan's algorithm is a modification of the topological sorting algorithm. By counting the nodes added to the queue, we can determine if the graph contains a cycle. If the count of processed nodes equals the total number of nodes in the graph, it implies the absence of cycles. def detect_cycle(graph): indegrees = [0] * len(graph) # Compute in-degrees of all nodes for node in range(len(graph)): for nbr in graph[node]: indegrees[nbr] += 1 queue = [] count = 0 for node in range(len(graph)): if indegrees[node] == 0: queue.append(node) count += 1 while queue: n = queue.pop(0) for nbr in graph[n]: indegrees[nbr] -= 1 if indegrees[nbr] == 0: queue.append(nbr) count += 1 return count != len(graph) If count == len(graph) : No cycle exists. If count != len(graph) : A cycle is present.","title":"Khan's Algorithm for Cycle Detection"},{"location":"graph/detect_cycle_in_directed_graph/#related-problems","text":"Leetcode - 207. Course Schedule Leetcode - 2392. Build a Matrix With Conditions","title":"Related Problems \ud83d\udcd5"}]}