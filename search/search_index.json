{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"backtracking/backtracking/","text":"Backtracking Backtracking is a strategy where we solve a problem for all possible patterns and stop after receiving the best solution. Finding valid permutation Problem Given a string \"ABC\" find out if permutation \"CBA\" is possible from all the characters of the string. Solution The permutations of string \"ABC\" are {\"ABC\", \"ACB\", \"BCA\", \"BAC\", \"CAB\", \"CBA\"}. As we can see the total number of permutations for \"ABC\" are Factorial(3) which equals 6 . And after generating the permutations \"CBA\" is also a valid permutation. We can solve this problem in a problem by applying backtracking as follows: class BacktrackingExample { public static boolean hasPermutation(String text, String pattern) { int[] usedMap = new int[text.length()]; return isPermutePossible(text, pattern, \"\", usedMap); } public static boolean isPermutePossible(String text, String pattern, String resultText, int[] usedMap) { if (text.length() > pattern.length()) { return false; } if (resultText.length() == text.length()) { if (pattern.equals(resultText)) { return true; } } for (int i = 0; i < text.length(); ++i) { if (usedMap[i] == 0) { // character is not used so far String newResultText = resultText + text.charAt(i); usedMap[i] = 1; // set character as used boolean isPossible = isPermutePossible(text, pattern, newResultText, usedMap); if (isPossible) { // solution is possible return true; // cut the branch } usedMap[i] = 0; // free character to be used again } } return false; } }","title":"Backtracking"},{"location":"backtracking/backtracking/#backtracking","text":"Backtracking is a strategy where we solve a problem for all possible patterns and stop after receiving the best solution.","title":"Backtracking"},{"location":"backtracking/backtracking/#finding-valid-permutation","text":"","title":"Finding valid permutation"},{"location":"backtracking/backtracking/#problem","text":"Given a string \"ABC\" find out if permutation \"CBA\" is possible from all the characters of the string.","title":"Problem"},{"location":"backtracking/backtracking/#solution","text":"The permutations of string \"ABC\" are {\"ABC\", \"ACB\", \"BCA\", \"BAC\", \"CAB\", \"CBA\"}. As we can see the total number of permutations for \"ABC\" are Factorial(3) which equals 6 . And after generating the permutations \"CBA\" is also a valid permutation. We can solve this problem in a problem by applying backtracking as follows: class BacktrackingExample { public static boolean hasPermutation(String text, String pattern) { int[] usedMap = new int[text.length()]; return isPermutePossible(text, pattern, \"\", usedMap); } public static boolean isPermutePossible(String text, String pattern, String resultText, int[] usedMap) { if (text.length() > pattern.length()) { return false; } if (resultText.length() == text.length()) { if (pattern.equals(resultText)) { return true; } } for (int i = 0; i < text.length(); ++i) { if (usedMap[i] == 0) { // character is not used so far String newResultText = resultText + text.charAt(i); usedMap[i] = 1; // set character as used boolean isPossible = isPermutePossible(text, pattern, newResultText, usedMap); if (isPossible) { // solution is possible return true; // cut the branch } usedMap[i] = 0; // free character to be used again } } return false; } }","title":"Solution"},{"location":"graph/detect_cycle_in_directed_graph/","text":"Detect Cycle in Directed Graph Given a directed graph represented as an adjacency list, the task is to determine if the graph contains any cycles. graph LR 1 --> 2 2 --> 3 3 --> 4 4 --> 2 Depth-First Search (DFS) Approach In an undirected graph , we use a visited[] array to track visited nodes and detect if a node is revisited, indicating a cycle. However, this approach does not work for directed graphs because nodes can be visited multiple times from different paths. For example, consider the following graph: graph LR 1 --> 2 3 --> 2 Here, node 2 can be visited twice, but that does not imply the presence of a cycle. Observing Sub-Graphs A directed graph can be seen as a collection of sub-graphs. In the graph above, there are two sub-graphs: 1 \u2192 2 and 3 \u2192 2 . Running a cycle detection algorithm independently on each sub-graph will detect cycles. For instance: for (each node in graph): new visited[]; if (detectCycle(node, visited, graph)): return true; While this approach works, it is inefficient as it repeatedly initializes the visited[] array and performs redundant checks. Optimized DFS Algorithm We can optimize the approach by: 1. Initializing the visited[] array once. 2. Introducing a processed[] array to track sub-graphs already checked for cycles. Here\u2019s the code: def detectCycle(graph): visited = [False] * len(graph) processed = [False] * len(graph) for node in range(len(graph)): if not processed[node]: if detectCycleUtil(node, graph, visited, processed): return True return False def detectCycleUtil(node, graph, visited, processed): visited[node] = True processed[node] = True for nbr in graph[node]: if visited[nbr]: # Cycle detected return True elif detectCycleUtil(nbr, graph, visited, processed): return True visited[node] = False return False visited[] : Tracks nodes visited in the current DFS traversal. processed[] : Tracks sub-graphs already checked for cycles. Breadth-First Search (BFS) Approach To understand the BFS-based approach, it\u2019s essential to first understand topological sorting for directed graphs. Consider the graph below: graph LR 1 --> 2 2 --> 3 3 --> 4 1 --> 4 This graph can be viewed as a dependency graph, where processing node 1 requires processing nodes 2 , 3 , and 4 first. The topological order of the graph reflects this dependency. Topological Sorting Algorithm Topological sorting processes nodes in decreasing order of their in-degrees . Below is the algorithm to print the topological order of a directed graph: def topological_sort(graph): indegrees = [0] * len(graph) # Compute in-degrees of all nodes for node in range(len(graph)): for nbr in graph[node]: indegrees[nbr] += 1 queue = [] for node in range(len(graph)): if indegrees[node] == 0: # Add nodes with 0 in-degree queue.append(node) while queue: n = queue.pop(0) print(n) # Process node for nbr in graph[n]: indegrees[nbr] -= 1 # Decrement in-degree if indegrees[nbr] == 0: queue.append(n) Khan's Algorithm for Cycle Detection Khan's algorithm is a modification of the topological sorting algorithm. By counting the nodes added to the queue, we can determine if the graph contains a cycle. If the count of processed nodes equals the total number of nodes in the graph, it implies the absence of cycles. def detect_cycle(graph): indegrees = [0] * len(graph) # Compute in-degrees of all nodes for node in range(len(graph)): for nbr in graph[node]: indegrees[nbr] += 1 queue = [] count = 0 for node in range(len(graph)): if indegrees[node] == 0: queue.append(node) count += 1 while queue: n = queue.pop(0) for nbr in graph[n]: indegrees[nbr] -= 1 if indegrees[nbr] == 0: queue.append(nbr) count += 1 return count != len(graph) If count == len(graph) : No cycle exists. If count != len(graph) : A cycle is present. Related Problems \ud83d\udcd5 Leetcode - 207. Course Schedule Leetcode - 2392. Build a Matrix With Conditions","title":"Detect Cycle in Directed Graph"},{"location":"graph/detect_cycle_in_directed_graph/#detect-cycle-in-directed-graph","text":"Given a directed graph represented as an adjacency list, the task is to determine if the graph contains any cycles. graph LR 1 --> 2 2 --> 3 3 --> 4 4 --> 2","title":"Detect Cycle in Directed Graph"},{"location":"graph/detect_cycle_in_directed_graph/#depth-first-search-dfs-approach","text":"In an undirected graph , we use a visited[] array to track visited nodes and detect if a node is revisited, indicating a cycle. However, this approach does not work for directed graphs because nodes can be visited multiple times from different paths. For example, consider the following graph: graph LR 1 --> 2 3 --> 2 Here, node 2 can be visited twice, but that does not imply the presence of a cycle.","title":"Depth-First Search (DFS) Approach"},{"location":"graph/detect_cycle_in_directed_graph/#observing-sub-graphs","text":"A directed graph can be seen as a collection of sub-graphs. In the graph above, there are two sub-graphs: 1 \u2192 2 and 3 \u2192 2 . Running a cycle detection algorithm independently on each sub-graph will detect cycles. For instance: for (each node in graph): new visited[]; if (detectCycle(node, visited, graph)): return true; While this approach works, it is inefficient as it repeatedly initializes the visited[] array and performs redundant checks.","title":"Observing Sub-Graphs"},{"location":"graph/detect_cycle_in_directed_graph/#optimized-dfs-algorithm","text":"We can optimize the approach by: 1. Initializing the visited[] array once. 2. Introducing a processed[] array to track sub-graphs already checked for cycles. Here\u2019s the code: def detectCycle(graph): visited = [False] * len(graph) processed = [False] * len(graph) for node in range(len(graph)): if not processed[node]: if detectCycleUtil(node, graph, visited, processed): return True return False def detectCycleUtil(node, graph, visited, processed): visited[node] = True processed[node] = True for nbr in graph[node]: if visited[nbr]: # Cycle detected return True elif detectCycleUtil(nbr, graph, visited, processed): return True visited[node] = False return False visited[] : Tracks nodes visited in the current DFS traversal. processed[] : Tracks sub-graphs already checked for cycles.","title":"Optimized DFS Algorithm"},{"location":"graph/detect_cycle_in_directed_graph/#breadth-first-search-bfs-approach","text":"To understand the BFS-based approach, it\u2019s essential to first understand topological sorting for directed graphs. Consider the graph below: graph LR 1 --> 2 2 --> 3 3 --> 4 1 --> 4 This graph can be viewed as a dependency graph, where processing node 1 requires processing nodes 2 , 3 , and 4 first. The topological order of the graph reflects this dependency.","title":"Breadth-First Search (BFS) Approach"},{"location":"graph/detect_cycle_in_directed_graph/#topological-sorting-algorithm","text":"Topological sorting processes nodes in decreasing order of their in-degrees . Below is the algorithm to print the topological order of a directed graph: def topological_sort(graph): indegrees = [0] * len(graph) # Compute in-degrees of all nodes for node in range(len(graph)): for nbr in graph[node]: indegrees[nbr] += 1 queue = [] for node in range(len(graph)): if indegrees[node] == 0: # Add nodes with 0 in-degree queue.append(node) while queue: n = queue.pop(0) print(n) # Process node for nbr in graph[n]: indegrees[nbr] -= 1 # Decrement in-degree if indegrees[nbr] == 0: queue.append(n)","title":"Topological Sorting Algorithm"},{"location":"graph/detect_cycle_in_directed_graph/#khans-algorithm-for-cycle-detection","text":"Khan's algorithm is a modification of the topological sorting algorithm. By counting the nodes added to the queue, we can determine if the graph contains a cycle. If the count of processed nodes equals the total number of nodes in the graph, it implies the absence of cycles. def detect_cycle(graph): indegrees = [0] * len(graph) # Compute in-degrees of all nodes for node in range(len(graph)): for nbr in graph[node]: indegrees[nbr] += 1 queue = [] count = 0 for node in range(len(graph)): if indegrees[node] == 0: queue.append(node) count += 1 while queue: n = queue.pop(0) for nbr in graph[n]: indegrees[nbr] -= 1 if indegrees[nbr] == 0: queue.append(nbr) count += 1 return count != len(graph) If count == len(graph) : No cycle exists. If count != len(graph) : A cycle is present.","title":"Khan's Algorithm for Cycle Detection"},{"location":"graph/detect_cycle_in_directed_graph/#related-problems","text":"Leetcode - 207. Course Schedule Leetcode - 2392. Build a Matrix With Conditions","title":"Related Problems \ud83d\udcd5"},{"location":"heap/priority_queue/","text":"Priority Queue (Max/Min Heap) A heap is a complete binary tree in which each node in the tree starting from root has value strictly greater than or less than children node's value. An example is shown below which shows max-heap which is a heap where the parent node has strictly greater value than it's child nodes. graph TD A[100] --> B[50] A --> C[30] B --> D[20] B --> E[10] C --> F[15] C --> G[5] Priority Queue is a queue data structure where values are dequeued based on the priority of the elements. The priority can be decided based on the weight or value of the element or some other factor if the element is complex. Heap lets us implement priority queue based on the value of the nodes. If the priority is decided by the value of the element then if the elements are to be dequeued based on maximum value first we implement a Max-Heap and if the elements have to be dequeued based on minimum value first then Min-Heap. Usage of Priority Queue in Java Here is an example of java code that we can use to code a priority queue of all the three kinds: min, max and custom. The lamda function is a custom comparator class. class PriorityQueueUsage { public static void main(String[] args) { // max-heap or max priority queue PriorityQueue<Integer> maxHeap = new PriorityQueue<>(); queue.add(1); queue.add(2); // min-heap or min priority queue PriorityQueue<Integer> minHeap = new PriorityQueue<>((p1, p2) -> { return -Integer.compare(p1, p2); }); // custom comparator priority queue PriorityQueue<CustomClass> customHeap = new PriorityQueue<>((p1, p2) -> { return Integer.compare(p1.val, p2.val); // val is a integer attribute }); } }","title":"Priority Queue"},{"location":"heap/priority_queue/#priority-queue-maxmin-heap","text":"A heap is a complete binary tree in which each node in the tree starting from root has value strictly greater than or less than children node's value. An example is shown below which shows max-heap which is a heap where the parent node has strictly greater value than it's child nodes. graph TD A[100] --> B[50] A --> C[30] B --> D[20] B --> E[10] C --> F[15] C --> G[5] Priority Queue is a queue data structure where values are dequeued based on the priority of the elements. The priority can be decided based on the weight or value of the element or some other factor if the element is complex. Heap lets us implement priority queue based on the value of the nodes. If the priority is decided by the value of the element then if the elements are to be dequeued based on maximum value first we implement a Max-Heap and if the elements have to be dequeued based on minimum value first then Min-Heap.","title":"Priority Queue (Max/Min Heap)"},{"location":"heap/priority_queue/#usage-of-priority-queue-in-java","text":"Here is an example of java code that we can use to code a priority queue of all the three kinds: min, max and custom. The lamda function is a custom comparator class. class PriorityQueueUsage { public static void main(String[] args) { // max-heap or max priority queue PriorityQueue<Integer> maxHeap = new PriorityQueue<>(); queue.add(1); queue.add(2); // min-heap or min priority queue PriorityQueue<Integer> minHeap = new PriorityQueue<>((p1, p2) -> { return -Integer.compare(p1, p2); }); // custom comparator priority queue PriorityQueue<CustomClass> customHeap = new PriorityQueue<>((p1, p2) -> { return Integer.compare(p1.val, p2.val); // val is a integer attribute }); } }","title":"Usage of Priority Queue in Java"}]}